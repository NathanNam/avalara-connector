/**
 * Mule Avalara Cloud Connector
 *
 * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 *
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.modules.avalara;

import java.math.BigDecimal;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.PostConstruct;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;

import org.apache.commons.beanutils.Converter;
import org.apache.commons.lang.Validate;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Module;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.modules.avalara.api.AvalaraClient;
import org.mule.modules.avalara.api.DefaultAvalaraClient;
import org.mule.modules.avalara.api.MapBuilder;
import org.mule.modules.avalara.exception.AvalaraRuntimeException;

import ar.com.zauber.commons.mom.CXFStyle;
import ar.com.zauber.commons.mom.MapObjectMapper;

import com.avalara.avatax.services.BaseAddress;
import com.avalara.avatax.services.CancelTaxRequest;
import com.avalara.avatax.services.CancelTaxResult;
import com.avalara.avatax.services.CommitTaxRequest;
import com.avalara.avatax.services.CommitTaxResult;
import com.avalara.avatax.services.GetTaxHistoryRequest;
import com.avalara.avatax.services.GetTaxHistoryResult;
import com.avalara.avatax.services.GetTaxRequest;
import com.avalara.avatax.services.GetTaxResult;
import com.avalara.avatax.services.PingResult;
import com.avalara.avatax.services.PostTaxRequest;
import com.avalara.avatax.services.PostTaxResult;
import com.avalara.avatax.services.ValidateRequest;
import com.avalara.avatax.services.ValidateResult;

/**
 * Avalara provides automated sales tax solutions to streamline cumbersome, 
 * error-prone tax compliance processes and reduce the risk of loss or penalty 
 * in case of an audit. Their automated solutions automatically perform address 
 * validation, jurisdiction research and rate calculation and allow you to 
 * manage even the most complicated tax issues, such as situs, nexus, tax tiers, 
 * tax holidays, exemptions, certificate management and product taxability rules.
 *
 * @author Gaston Ponti
 */
@Module(name = "avalara", schemaVersion = "1.0-SNAPSHOT")
public class AvalaraModule
{
    /**
     * Avalara's account
     */
    @Configurable
    private String account;

    /**
     * Avalara's license
     */
    @Configurable
    private String license;
    
    /**
     * Avalara's apiClient
     */
    @Configurable
    private String avalaraClient;
    
    /**
     * Avalara's application client. By default uses DefaultAvalaraClient class.
     */
    @Configurable
    @Optional
    private AvalaraClient apiClient;
    
    private MapObjectMapper mom = new MapObjectMapper("com.avalara.avatax.services");
    
    public PingResult ping(String message)
    {
        return apiClient.ping(message);
    }
    
    /**
     * Get Tax processor.
     * <p>
     * The Get Tax operation calculates tax for one or more invoiced items and 
     * displays details describing the calculation of tax for each line item.
     *
     * {@sample.xml ../../../doc/avalara-connector.xml.sample avalara:get-tax}
     * 
     * @param companyCode Client application company reference code
     * @param docType The document type specifies the category of the document and affects
     *                how the document is treated after a tax calculation; see 
     *                {@link AvalaraDocumentType} for more information about the specific 
     *                document types.
     * @param docCode The internal reference code used by the client application.
     * @param docDate Date of invoice, purchase order, etc.
     * @param salespersonCode The client application salesperson reference code.
     * @param customerCode Client application customer reference code 
     * @param customerUsageType Client application customer or usage type.
     *                          CustomerUsageType determines the exempt status of 
     *                          the transaction based on the exemption tax rules for 
     *                          the jurisdictions involved. CustomerUsageType may 
     *                          also be set at the line item level. <p>
     *                          The standard values for the CustomerUsageType (A-L).<br/>
        A Federal Government<br/>
        B State/Local Govt.<br/>
        C Tribal Government<br/>
        D Foreign Diplomat<br/>
        E Charitable Organization<br/>
        F Religious/Education<br/>
        G Resale<br/>
        H Agricultural Production<br/>
        I Industrial Prod/Mfg.<br/>
        J Direct Pay Permit<br/>
        K Direct Mail<br/>
        L - Other
     * @param discount The discount amount to apply to the document. The string
     *                 represents a {@link BigDecimal}.
     * @param purchaseOrderNo Purchase order identifier. PurchaseOrderNo is required 
     *                        for single use exemption certificates to match the 
     *                        order and invoice with the certificate.
     * @param exemptionNo Exemption number used for this transaction
     * @param originCode Code that refers one of the address of the baseAddress collection.
     *                   It has to be the same code of one of the address's addressCode.
     *                   It represents the origin address. 
     * @param destinationCode Code that refers one of the address of the baseAddress collection.
     *                        It has to be the same code of one of the address's addressCode.
     *                        It represents the destination address. 
     * @param baseAddresses Collection of physical addresses that will be referred 
     *                      to as the destination or origination of 1 or more invoice 
     *                      line entries
     * @param listOfLines Collection of invoice lines requiring tax calculation
     * @param detailLevel Specifies the level of tax detail to return
     * @param referenceCode For returns (see {@link AvalaraDocumentType}), refers to the 
     *                      {@link GetTaxRequest#getDocCode} of the original invoice.
     * @param locationCode Location Code value. It is Also referred to as a Store 
     *                     Location, Outlet Id, or Outlet code is a number assigned by 
     *                     the State which identifies a Store location. Some state returns 
     *                     require taxes are broken out separately for Store Locations.
     * @param commit Commit flag. If Commit is set to true, tax for the transaction 
     *               is saved, posted and committed as tax document.
     * @param batchCode The batchCode value.
     * @param taxOverride Indicates to apply tax override to the document.
     * @param currencyCode It is 3 character ISO 4217 currency code.
     * @param serviceMode This is only supported by AvaLocal servers. It provides the 
     *                    ability to controls whether tax is calculated locally or remotely 
     *                    when using an AvaLocal server. The default is Automatic which 
     *                    calculates locally unless remote is necessary for non-local 
     *                    addresses.
     * @param paymentDate The date on which payment was made.
     * @param exchangeRate The exchange rate value. The string represents a 
     *                     {@link BigDecimal}
     * @param exchangeRateEffDate The exchange rate effective date value.
     * @return The {@link GetTaxResult}
     * 
     * @throws AvalaraRuntimeException
     */
    @Processor
    public GetTaxResult getTax(String companyCode,
                               AvalaraDocumentType docType,
                               @Optional String docCode,
                               Date docDate,
                               @Optional String salespersonCode,
                               String customerCode,
                               @Optional String customerUsageType,
                               String discount,
                               @Optional String purchaseOrderNo,
                               @Optional String exemptionNo,
                               String originCode,
                               String destinationCode,
                               List<Map<String, Object>> baseAddresses,
                               List<Map<String, Object>> listOfLines,
                               DetailLevelType detailLevel,
                               @Optional String referenceCode,
                               @Optional String locationCode,
                               @Optional @Default("false") boolean commit,
                               @Optional String batchCode,
                               @Optional Map<String, Object> taxOverride,
                               @Optional String currencyCode,
                               @Optional @Default("AUTOMATIC") ServiceModeType serviceMode,
                               Date paymentDate,
                               String exchangeRate,
                               Date exchangeRateEffDate)
    {
        BigDecimal discountDecimal = discount == null ? null :  new BigDecimal(discount);
        BigDecimal exchangeRateDecimal = exchangeRate == null ? null :  new BigDecimal(exchangeRate);
        
        Map<String, Object> addresses = null;
        if (baseAddresses != null && !baseAddresses.isEmpty())
        {
            addresses = new HashMap<String, Object>();
            addresses.put("baseAddress", baseAddresses);
        }
        
        Map<String, Object> lines = null;
        if (listOfLines != null && !listOfLines.isEmpty())
        {
            lines = new HashMap<String, Object>();
            lines.put("line", listOfLines);
        }
        
        return apiClient.sendToAvalara(TaxRequestType.GetTax, mom.toObject(GetTaxRequest.class,            
                new MapBuilder()
                .with("companyCode", companyCode)
                .with("docType", docType.toDocumentType())
                .with("docCode", docCode)
                .with("docDate", docDate)
                .with("salespersonCode", salespersonCode)
                .with("customerCode", customerCode)
                .with("customerUsageType", customerUsageType)
                .with("discount", discountDecimal)
                .with("purchaseOrderNo", purchaseOrderNo)
                .with("exemptionNo", exemptionNo)
                .with("originCode", originCode)
                .with("destinationCode", destinationCode)
                .with("addresses", addresses)
                .with("lines", lines)
                .with("detailLevel", detailLevel.toAvalaraDetailLevel())
                .with("referenceCode", referenceCode)
                .with("locationCode", locationCode)
                .with("commit", commit) 
                .with("batchCode", batchCode)
                .with("taxOverride", taxOverride)
                .with("currencyCode", currencyCode)
                .with("serviceMode", serviceMode.toAvalaraServiceMode())
                .with("paymentDate", paymentDate)
                .with("exchangeRate", exchangeRateDecimal)
                .with("exchangeRateEffDate", exchangeRateEffDate)
                .build()
            )
        );
    }

    /**
     * Post Tax processor
     *
     * {@sample.xml ../../../doc/avalara-connector.xml.sample avalara:post-tax}
     *
     * @param docId The original document's type, such as Sales Invoice or Purchase Invoice.
     * @param companyCode Client application company reference code. If docId is specified, 
     *                    this is not needed.
     * @param docType The document type specifies the category of the document and affects
     *                how the document is treated after a tax calculation; see 
     *                {@link AvalaraDocumentType} for more information about the specific 
     *                document types.
     * @param docCode The internal reference code used by the client application.
     * @param docDate The date on the invoice, purchase order, etc
     * @param totalAmount The total amount (not including tax) for the document.
     *                    This is used for verification and reconciliation. This should 
     *                    be the <b>TotalAmount</b> returned by {@link GetTaxResult} when 
     *                    tax was calculated for this document; otherwise the web service 
     *                    will return an error. The string represents a {@link BigDecimal}
     * @param totalTax The total tax for the document. This is used for verification 
     *                 and reconciliation. This should be the <b>TotalTax</b> returned by
     *                 {@link GetTaxResult} when tax was calculated for this document; 
     *                 otherwise the web service will return an error.
     *                 The string represents a {@link BigDecimal}
     * @param commit The commit value. This has been defaulted to false. If this has 
     *               been set to true AvaTax will commit the document on this call. Seller's 
     *               system who wants to Post and Commit the document on one call should use 
     *               this flag.
     * @param newDocCode The new document code value.
     * @return The {@link PostTaxResult}
     * 
     * @throws AvalaraRuntimeException
     */
    @Processor
    public PostTaxResult postTax(@Optional String docId,
                                 String companyCode,
                                 AvalaraDocumentType docType,
                                 @Optional String docCode,
                                 Date docDate,
                                 String totalAmount,
                                 String totalTax,
                                 @Optional @Default("false") boolean commit,
                                 @Optional String newDocCode)
    {
        BigDecimal totalAmountDecimal = totalAmount == null ? null :  new BigDecimal(totalAmount);
        BigDecimal totalTaxDecimal = totalTax == null ? null :  new BigDecimal(totalTax);
        
        return (PostTaxResult) apiClient.sendToAvalara(TaxRequestType.PostTax,
            mom.toObject(PostTaxRequest.class,            
                new MapBuilder()
                .with("docId", docId)
                .with("companyCode", companyCode)
                .with("docType", docType.toDocumentType())
                .with("docCode", docCode)
                .with("docDate", docDate)
                .with("totalAmount", totalAmountDecimal)
                .with("totalTax", totalTaxDecimal)
                .with("commit", commit)
                .with("newDocCode", newDocCode)
                .build()
            )
        );
    }
    
    /**
     * Commit Tax processor
     *
     * {@sample.xml ../../../doc/avalara-connector.xml.sample avalara:commit-tax}
     *
     * @param docId The original document's type, such as Sales Invoice or Purchase Invoice.
     * @param companyCode Client application company reference code. If docId is specified, 
     *                    this is not needed.
     * @param docType The document type specifies the category of the document and affects
     *                how the document is treated after a tax calculation; see 
     *                {@link AvalaraDocumentType} for more information about the specific 
     *                document types.
     * @param docCode The internal reference code used by the client application.
     * @param newDocCode The new document code value.
     * @return The {@link CommitTaxRequest}
     * 
     * @throws AvalaraRuntimeException
     */
    @Processor
    public CommitTaxResult commitTax(@Optional String docId,
                                     String companyCode,
                                     AvalaraDocumentType docType,
                                     @Optional String docCode,
                                     @Optional String newDocCode)
    {
        return (CommitTaxResult) apiClient.sendToAvalara(TaxRequestType.CommitTax,
            mom.toObject(CommitTaxRequest.class,            
                new MapBuilder()
                .with("docId", docId)
                .with("companyCode", companyCode)
                .with("docType", docType.toDocumentType())
                .with("docCode", docCode)
                .with("newDocCode", newDocCode)
                .build()
            )
        );
    }
    
    /**
     * Get Tax History processor
     *
     * {@sample.xml ../../../doc/avalara-connector.xml.sample avalara:get-tax-history}
     *
     * @param docId The original document's type, such as Sales Invoice or Purchase Invoice.
     * @param companyCode Client application company reference code. If docId is specified, 
     *                    this is not needed.
     * @param docType The document type specifies the category of the document and affects
     *                how the document is treated after a tax calculation; see 
     *                {@link AvalaraDocumentType} for more information about the specific 
     *                document types.
     * @param docCode The internal reference code used by the client application.
     * @param detailLevel Specifies the level of detail to return. See {@link DetailLevelType}.
     * @return The {@link GetTaxHistoryResult}
     * 
     * @throws AvalaraRuntimeException
     */
    @Processor
    public GetTaxHistoryResult getTaxHistory(@Optional String docId,
                                             String companyCode,
                                             AvalaraDocumentType docType,
                                             @Optional String docCode,
                                             DetailLevelType detailLevel)
    {
        return (GetTaxHistoryResult) apiClient.sendToAvalara(TaxRequestType.GetTaxHistory,
            mom.toObject(GetTaxHistoryRequest.class,            
                new MapBuilder()
                .with("docId", docId)
                .with("companyCode", companyCode)
                .with("docType", docType.toDocumentType())
                .with("docCode", docCode)
                .with("detailLevel", detailLevel.toAvalaraDetailLevel())
                .build()
            )
        );
    }
    
    /**
     * Cancel tax, indicating the document that should be cancelled and the reason
     * for the operation.
     *
     * {@sample.xml ../../../doc/avalara-connector.xml.sample avalara:cancel-tax}
     * 
     * @param docId The original document's type, such as Sales Invoice or Purchase Invoice.
     * @param companyCode Client application company reference code. If docId is specified, 
     *                    this is not needed.
     * @param docType The document type specifies the category of the document and affects
     *                how the document is treated after a tax calculation; see 
     *                {@link AvalaraDocumentType} for more information about the specific 
     *                document types.
     * @param docCode The internal reference code used by the client application.
     * @param cancelCode A code indicating the reason the document is getting canceled.
     * @return The {@link CancelTaxResult}
     * 
     * @throws AvalaraRuntimeException
     */
    @Processor
    public CancelTaxResult cancelTax(@Optional String docId,
                                     String companyCode,
                                     AvalaraDocumentType docType,
                                     @Optional String docCode,
                                     CancelCodeType cancelCode)
    {
        return (CancelTaxResult) apiClient.sendToAvalara(TaxRequestType.CancelTax,
            mom.toObject(CancelTaxRequest.class,            
                new MapBuilder()
                .with("docId", docId)
                .with("companyCode", companyCode)
                .with("docType", docType.toDocumentType())
                .with("docCode", docCode)
                .with("cancelCode", cancelCode.toAvalaraCancelCode())
                .build()
            )
        );
    }
    
    /**
     * Validate Address processor.
     * <p>
     * This operation validates the supplied address, returning canonical form and 
     * additional delivery details if successfully validated.
     *
     * {@sample.xml ../../../doc/avalara-connector.xml.sample avalara:validate-address}
     * @param line1 Address line 1
     * @param line2 Address line 2
     * @param line3 Address line 3
     * @param city City name. Required, when PostalCode is not specified.
     * @param region State or region name. Requirad, when PostalCode is not specified.
     * @param country Country code
     * @param postalCode Postal or ZIP code. Required, when City and Region are not 
     *                   specified
     * @param addressCode the address code.
     * @param taxRegionId The tax region id.
     * @param latitude Latitude. 
     * @param longitude Longitude.
     * @param textCase The casing to apply to the validated address(es).
     * @param coordinates True, if you want in the result a not empty latitud and longitude.
     * @param taxability True, if you want the valid taxRegionId in the result.
     * @param date Date.
     * @return The {@link ValidateResult}
     * 
     * @throws AvalaraRuntimeException
     */
    @Processor
    public ValidateResult validateAddress(String line1,
                                          @Optional String line2,
                                          @Optional String line3, 
                                          @Optional String city,
                                          @Optional String region,
                                          @Optional String country,
                                          @Optional String postalCode,
                                          @Optional String addressCode,
                                          @Optional int taxRegionId,
                                          @Optional String latitude,
                                          @Optional String longitude,
                                          @Optional @Default("DEFAULT") TextCaseType textCase,
                                          @Optional @Default("false") boolean coordinates,
                                          @Optional @Default("false") boolean taxability,
                                          Date date)
    {
        BaseAddress address = new BaseAddress();
        address.setAddressCode(addressCode);
        address.setCity(city);
        address.setCountry(country);
        address.setLatitude(latitude);
        address.setLine1(line1);
        address.setLine2(line2);
        address.setLine3(line3);
        address.setLongitude(longitude);
        address.setPostalCode(postalCode);
        address.setRegion(region);
        address.setTaxRegionId(taxRegionId);
        
        return apiClient.validateAddress(
            mom.toObject(ValidateRequest.class,            
                new MapBuilder()
                .with("address", address)
                .with("textCase", textCase.toAvalaraTextCase())
                .with("coordinates", coordinates)
                .with("taxability", taxability)
                .with("date", date)
                .build()
            )
        );
    }
    /**
     * 
     */
    @PostConstruct
    public void init()
    {
        if (apiClient == null )
        {
            Validate.notNull(account);
            Validate.notNull(license);
            Validate.notNull(avalaraClient);
            apiClient = new DefaultAvalaraClient(account, license, avalaraClient);
        }
        mom.setPropertyStyle(CXFStyle.STYLE);
    }
    
    /**
     * Returns the account.
     * 
     * @return  with the account.
     */
    
    public String getAccount()
    {
        return account;
    }

    /**
     * Returns the license.
     * 
     * @return  with the license.
     */
    
    public String getLicense()
    {
        return license;
    }

    /**
     * Returns the avalaraClient.
     * 
     * @return  with the avalaraClient.
     */
    
    public String getAvalaraClient()
    {
        return avalaraClient;
    }
    /**
     * Sets the avalaraClient. 
     *
     * @param avalaraClient  with the avalaraClient.
     */
    
    public void setAvalaraClient(String avalaraClient)
    {
        this.avalaraClient = avalaraClient;
    }
    /**
     * Sets the account. 
     *
     * @param account  with the account.
     */
    
    public void setAccount(String account)
    {
        this.account = account;
    }
    /**
     * Sets the license. 
     *
     * @param license  with the license.
     */
    
    public void setLicense(String lisence)
    {
        this.license = lisence;
    }
    /**
     * Returns the apiClient.
     * 
     * @return  with the apiClient.
     */
    
    public AvalaraClient getApiClient()
    {
        return apiClient;
    }

    /**
     * Sets the apiClient. 
     *
     * @param apiClient  with the apiClient.
     */
    
    public void setClient(AvalaraClient client)
    {
        this.apiClient = client;
    }
    
    private final DatatypeFactory datatypeFactory;
    {
        mom.registerConverter(new Converter()
        {
            
            @SuppressWarnings("rawtypes")
            @Override
            public Object convert(Class arg0, Object arg1)
            {
                Validate.isTrue(arg0 == XMLGregorianCalendar.class);
                
                return toGregorianCalendar((Date) arg1);
            }
        }, XMLGregorianCalendar.class);
        try
        {
            datatypeFactory = DatatypeFactory.newInstance();
        }
        catch (DatatypeConfigurationException e)
        {
            throw new AssertionError(e);
        }
    }
    
    private XMLGregorianCalendar toGregorianCalendar(Date openingBalanceDate)
    {
        GregorianCalendar cal = new GregorianCalendar();
        cal.setTime(openingBalanceDate);
        return datatypeFactory.newXMLGregorianCalendar(cal);
    }
}
